import type { TableMetadata, ColumnMeta, GeneratedFile, GeneratedTable } from './types.js';

const TYPE_MAP: Record<string, string> = {
  string: 'string',
  number: 'number',
  boolean: 'boolean',
  date: 'string',
  uuid: 'string',
  json: 'Record<string, unknown>',
};

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
}

function mapColumnType(type: string): string {
  return TYPE_MAP[type] ?? 'unknown';
}

function generateEnumType(options: Array<{ value: string | number | boolean }>): string {
  const values = options.map(o => JSON.stringify(o.value)).join(' | ');
  return values;
}

function generateRowInterface(
  tableName: string,
  columns: ColumnMeta[]
): string {
  const interfaceName = `${toPascalCase(tableName)}Row`;
  
  const fields = columns
    .filter(col => !col.hidden)
    .map(col => {
      const tsType = col.options 
        ? generateEnumType(col.options)
        : mapColumnType(col.type);
      const nullable = col.type === 'date' && !col.computed ? ' | null' : '';
      return `  ${col.name}: ${tsType}${nullable};`;
    })
    .join('\n');

  return `export interface ${interfaceName} {\n${fields}\n}`;
}

function generateFiltersInterface(
  tableName: string,
  columns: ColumnMeta[],
  filters: TableMetadata['filters']
): string {
  const interfaceName = `${toPascalCase(tableName)}Filters`;

  if (filters.length === 0) {
    return `export interface ${interfaceName} {}`;
  }

  const fields = filters.map(f => {
    const col = columns.find(c => c.name === f.field);
    const valueType = col?.options 
      ? generateEnumType(col.options)
      : mapColumnType(f.type);

    const operators = f.operators.filter(op => !['isNull', 'isNotNull'].includes(op));
    
    if (operators.length === 0) {
      return `  ${f.field}?: { operator: 'isNull' | 'isNotNull' };`;
    }

    const operatorUnion = operators.map(op => `'${op}'`).join(' | ');
    
    if (f.type === 'date' || f.type === 'number') {
      return `  ${f.field}?: { operator: ${operatorUnion}; value: ${valueType} | [${valueType}, ${valueType}] };`;
    }
    
    if (['in', 'notIn'].some(op => operators.includes(op))) {
      return `  ${f.field}?: { operator: ${operatorUnion}; value: ${valueType} | ${valueType}[] };`;
    }

    return `  ${f.field}?: { operator: ${operatorUnion}; value: ${valueType} };`;
  }).join('\n');

  return `export interface ${interfaceName} {\n${fields}\n}`;
}

function generateColumnType(
  tableName: string,
  columns: ColumnMeta[]
): string {
  const interfaceName = `${toPascalCase(tableName)}Row`;
  return `export type ${toPascalCase(tableName)}Column = keyof ${interfaceName};`;
}

function generateAdapterFunction(
  tableName: string,
  apiName: string
): string {
  const pascalName = toPascalCase(tableName);
  const camelName = toCamelCase(tableName) + 'Adapter';
  const functionName = `create${pascalName}Adapter`;

  return `export function ${functionName}(options: {
  baseUrl: string;
  headers?: Record<string, string> | (() => Record<string, string> | Promise<Record<string, string>>);
}): import('@tablecraft/table').DataAdapter<${pascalName}Row> {
  return import('@tablecraft/table').then(({ createTableCraftAdapter }) =>
    createTableCraftAdapter<${pascalName}Row>({
      ...options,
      table: '${apiName}',
    })
  ) as any;
}

export async function ${camelName}(options: {
  baseUrl: string;
  headers?: Record<string, string> | (() => Record<string, string> | Promise<Record<string, string>>);
}): Promise<import('@tablecraft/table').DataAdapter<${pascalName}Row>> {
  const { createTableCraftAdapter } = await import('@tablecraft/table');
  return createTableCraftAdapter<${pascalName}Row>({
    ...options,
    table: '${apiName}',
  });
}`;
}

export function generateTableFile(
  metadata: TableMetadata,
  version: string
): GeneratedTable {
  const { name, columns, filters } = metadata;
  const pascalName = toPascalCase(name);
  const kebabName = toKebabCase(name);

  const header = `// AUTO-GENERATED by @tablecraft/codegen
// DO NOT EDIT MANUALLY
// @tablecraft-version: ${version}
// @tablecraft-table: ${name}
// Generated: ${new Date().toISOString()}

`;

  const rowInterface = generateRowInterface(name, columns);
  const filtersInterface = generateFiltersInterface(name, columns, filters);
  const columnType = generateColumnType(name, columns);
  const adapterFunction = generateAdapterFunction(name, name);

  const content = header + [
    rowInterface,
    '',
    filtersInterface,
    '',
    columnType,
    '',
    adapterFunction,
  ].join('\n');

  return {
    tableName: name,
    filename: `${kebabName}.ts`,
    rowType: `${pascalName}Row`,
    filtersType: `${pascalName}Filters`,
    columnType: `${pascalName}Column`,
    adapterFunction: `create${pascalName}Adapter`,
    content,
  };
}

export function generateIndexFile(
  tables: GeneratedTable[]
): GeneratedFile {
  const exports = tables.map(t => {
    const kebabName = toKebabCase(t.tableName);
    return `export * from './${kebabName}';`;
  }).join('\n');

  const content = `// AUTO-GENERATED by @tablecraft/codegen
// DO NOT EDIT MANUALLY
// Generated: ${new Date().toISOString()}

${exports}
`;

  return {
    filename: 'index.ts',
    content,
  };
}

export function generatePackageJson(): GeneratedFile {
  const content = `{
  "name": "tablecraft-types",
  "version": "0.0.1",
  "main": "./index.js",
  "types": "./index.d.ts",
  "exports": {
    ".": {
      "import": "./index.js",
      "types": "./index.d.ts"
    }
  },
  "peerDependencies": {
    "@tablecraft/table": ">=0.0.1"
  }
}
`;

  return {
    filename: 'package.json',
    content,
  };
}